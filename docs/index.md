<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

### Table of Contents

*   [Mango][1]
    *   [Parameters][2]
    *   [Examples][3]
    *   [findNode][4]
        *   [Parameters][5]
        *   [Examples][6]
    *   [buildAndMergeNode][7]
        *   [Parameters][8]
        *   [Examples][9]
    *   [buildAndMergeRelationship][10]
        *   [Parameters][11]
        *   [Examples][12]
    *   [mergeEnhancedNode][13]
        *   [Parameters][14]
        *   [Examples][15]
    *   [mergeEnhancedNodes][16]
        *   [Parameters][17]
        *   [Examples][18]
    *   [buildAndMergeEnhancedNode][19]
        *   [Parameters][20]
        *   [Examples][21]
    *   [buildAndMergeEnhancedNodes][22]
        *   [Parameters][23]
        *   [Examples][24]
    *   [deleteNode][25]
        *   [Parameters][26]
        *   [Examples][27]
    *   [decomposeProps][28]
        *   [Parameters][29]
        *   [Examples][30]
    *   [search][31]
        *   [Parameters][32]
*   [ConditionContainer][33]
    *   [Parameters][34]
    *   [getType][35]
    *   [toObject][36]

## Mango

*   **See**: module:Builder
*   **See**: module:Engine

Mango is a user-friendly Object-To-Graph Mapper build on top of Neo4j's official
JavaScript Driver.

At this moment \[2022-02-22] the version 1.0.1 is opinionated insofar as its main
purpose has been to help build Knowledge Graphs (aka KG). These KGs would be based on
preserving unique Entities (aka Nodes) and Relationships between Nodes.

The key driving motive was to design a tool which would help ensure that there are no
copies of the same Node.

The idea came up when I worked for a family office and was dealing with bits and pieces
of data coming across my desk. I noticed that I would spend most of my time and effort
not on the value-generating activities relating to the data, but on solving questions
like:

*   What is the correct full address of Person X?
*   Did we send that document to Y?
*   Where can I find Z?

It was obvious that the solutions to these questions (99% of time that would be a
source document, or colleague's advice) resided within my colleague's minds or on their
desktops/emails.

We did have an old and limited database that had some records of some legal entities
and natural persons - but to use that knowledge it had to be checked and double-checked
with colleagues first. Which in 50% of situations required them requesting the info from
their counterparties.

The problem was that once all the effort was made and the relevant info was received,
verified and utilized, it was simply forgotten until the next time when same problem
arrived. And when it did, usually after a prolonged period of time, no one could easily
locate the previous result to reduce the amount of cognitive work.

Simple solution was to agree to share all such hard-earned knowledge, but:

*   There was no simple way to do it. We tried Confluence - but it required a learning
    curve that no one wanted. Everyone want to go on writing emails and making phone calls.
*   No one wants to archive. Archiving is a difficult mental work which is not rewarded
    in an obvious, immediate way. Therefore no one does it. This creates a huge (but
    familiar) tech debt in a form of knowledge search, repeating same work that already
    has been done. On the upside this is how office workers1.0 justify the time they spend
    in the office getting paid.

### Parameters

*   `config` **[Object][37]** Configuration object.

    *   `config.engine` **Engine** Instance of an Engine class. If none is supplied, Mango will look for config.engineConfig. If that does not exist or is unusable, a NoEngineError will be thrown.
    *   `config.engineConfig` **[Object][37]** Configuration object to instantiate connection to Neo4j.

        *   `config.engineConfig.username` **[string][38]** Neo4j DBMS username.
        *   `config.engineConfig.password` **[string][38]** Neo4j DBMS password.
        *   `config.engineConfig.ip` **[string][38]?** Neo4j DBMS IP to connect to. (optional, default `'0.0.0.0'`)
        *   `config.engineConfig.port` **[string][38]?** Neo4j DBMS port to use (optional, default `'7687'`)
        *   `config.engineConfig.database` **[string][38]?** Neo4j DBMS database name to use. (optional, default `'neo4j'`)
    *   `config.builder` **Builder?** Instance of a Builder class. If none is supplied, a generic one will be instantiated for you. (optional, default `newBuilder()`)

### Examples

```javascript
const mango = new Mango({
 engineConfig: {
   username: 'neo4j',
   password: 'neo4jpass',
 }
}); // connects to Neo4j DBMS instance running on 0.0.0.0:7687 and uses 'neo4j' database
```

### findNode

Main method to search for data in Neo4j.

#### Parameters

*   `labels` **[Array][39]<[string][38]>** Array of labels to match Nodes by.
*   `props` **[Object][37]** A POJO containing key:value to search for matches.
*   `config` **[Object][37]** Configuration object. (optional, default `{}`)

    *   `config.exactMatch` **[boolean][40]** {true} Mango searches for exactly what we specified, ie the returned Nodes must not have any extra properties above supplied labels & properties. You get exactly what you asked for.{false} Mango matches any Nodes that have supplied labels and properties and the returned result may contain Nodes with extra properties. You may get more than you asked for. (optional, default `false`)
    *   `config.returnResult` **[boolean][40]** {true} returns a Result with additional Neo4j query data.{false} return Node\[]. (optional, default `false`)

#### Examples

```javascript
const rv =
 mango
 .findNode(["Person"], { NAME: 'Bob' })
 .then(nodes => {
   console.log(nodes.length) // 2 <- we found 2 Nodes with NAME == 'Bob'
   console.log(nodes[0].getProperty("fullName")) // Bob Dylan
   console.log(nodes[1].getProperty("fullName")) // Bob Marley
 })
```

Returns **[Promise][41]<(Result | [Array][39]<[Node][42]>)>** 

### buildAndMergeNode

Builds a Node and merges it into Neo4j.

#### Parameters

*   `labels` **[Array][39]<[string][38]>** Array of labels to match Nodes by.
*   `props` **[Object][37]** A POJO with properties to construct and merge a Node to Neo4j. !MUST contain at least one label and a REQUIRED property to be unique (Uniqueness Requirement).
*   `config` **[Object][37]** Configuration object. (optional, default `{}`)

    *   `config.returnResult` **[boolean][40]** {true} returns a Result with additional Neo4j query data.{false} returns EnhancedNode. (optional, default `false`)

#### Examples

```javascript
const node =
 await mango.buildAndMergeNode(["Product"], { NAME: "Sweet Mango" });

 console.log(node.isWritten());  // true <- Neo4j has a (Product { NAME: "Sweet Mango", _hash:str, _uuid:str, _date_created: TimeArray })
 console.log(node.getId());      // 1 <- Neo4j's Id for this Node
```

Returns **[Promise][41]<(Result | EnhancedNode)>** 

### buildAndMergeRelationship

Builds a Relationship and merges it to Neo4j.
Needs no direction, as it is set by the position of startNode & endNode.
Namely, (startNode)-\[:RELATIONSHIP]->(endNode).

#### Parameters

*   `startNode` **([Node][42] | EnhancedNode)** Node that has an outbound Relationship.
*   `relationship` **(SimplifiedRelationshipArray | SimplifiedRelationshipObject)** \[\["REL_TYPES"], "required" | "optional", { relProps } ] | { labels: string\[], properties: Object, necessity: "required" | "optional" }.
*   `endNode` **([Node][42] | EnhancedNode)** Node that has an inbound Relationship.
*   `config` **[Object][37]** Configuration object. (optional, default `{}`)

    *   `config.returnResult` **[boolean][40]** {true} returns a Result with additional Neo4j query data.{false} returns Relationship. (optional, default `false`)

#### Examples

```javascript
// Find Nodes.
const bob = await mango.buildAndMergeNode(["Person"], {
 FULL_NAME: "SpongeBob SquarePants",
});
const patrick = await mango.buildAndMergeNode(["Person"], {
 FULL_NAME: "Patrick Star",
});

// Build a beautiful friendship!
const relationship = await mango.buildAndMergeRelationship(
 bob,
 {
   labels: ["IS_FRIENDS_WITH"],
   properties: { since: "lazyDriver?: booleanforever" },
 }
 patrick
);


// Check
// (:Person { FULL_NAME: "SpongeBob SquarePants" })-[:IS_FRIENDS_WITH { since: "forever" }]->(:Person { FULL_NAME: "Patrick Star" })
// exists
console.log(relationship.isWritten()) // true
```

Returns **[Promise][41]<(Result | Relationship)>** 

### mergeEnhancedNode

Merges EnhancedNode into Neo4j.
Separates the building of Nodes/Relationships from their merging stage. You have to build EnhancedNodes
with new Builder().buildEnhancedNodes first and then merge with this method.

#### Parameters

*   `enode` **EnhancedNode** EnhancedNode to merge into Neo4j.
*   `config` **[Object][37]** Configuration object. (optional, default `{}`)

    *   `config.returnResult` **[boolean][40]** {true} returns a Result with additional Neo4j query data.{false} returns EnhancedNode. (optional, default `false`)

#### Examples

```javascript
// Merge a pattern to Neo4j:
// (:Person { NAME: "SpongeBob" })-[:HAS_FRIEND]->(:Person { NAME: "Patrick" })

const person: EnhancedNode = builder.makeEnhancedNode(
  // specify core, or "start", node
  builder.makeNode(["Person"], { NAME: "SpongeBob" }),
  // specify relationships
  [
    builder.makeRelationshipCandidate(
      ["HAS_FRIEND"],
      // specify the endNode
      builder.makeNode(["Person"], { NAME: "Patrick" })
    ),
  ]
);

const enode: EnhancedNode = await mango.mergeEnhancedNode(person)
console.log(enode.isWritten()); // true
```

Returns **[Promise][41]<(Result | EnhancedNode)>** 

### mergeEnhancedNodes

Merges EnhancedNodes into Neo4j.
A batch variant of Mango.mergeEnhancedNode.

#### Parameters

*   `enodes` **[Array][39]\<EnhancedNode>** EnhancedNode\[] to merge into Neo4j.
*   `config` **[Object][37]** Configuration object. (optional, default `{}`)

    *   `config.returnResult` **[boolean][40]** {true} returns a Result with additional Neo4j query data.{false} returns EnhancedNode\[]. (optional, default `false`)

#### Examples

```javascript
// Merge a pattern to Neo4j:
// (:Person { NAME: "SpongeBob" })-[:HAS_FRIEND]->(:Person { NAME: "Patrick" })
// (:TVSeries { NAME: "SpongeBob SquarePants" })-[:HAS_WIKIPAGE]->(:Webpage { URL: "https://en.wikipedia.org/wiki/SpongeBob_SquarePants" })

const person: EnhancedNode = builder.makeEnhancedNode(
  // specify core, or "start", node
  builder.makeNode(["Person"], { NAME: "SpongeBob" }),
  // specify relationships
  [
    builder.makeRelationshipCandidate(
      ["HAS_FRIEND"],
      // specify the endNode
      builder.makeNode(["Person"], { NAME: "Patrick" })
    ),
  ]
);

const wiki: EnhancedNode = builder.makeEnhancedNode(
   builder.makeNode(["TVSeries"], { NAME: "SpongeBob SquarePants" }),
   [
     builder.makeRelationshipCandidate(
       ["HAS_WIKIPAGE"],
       builder.makeNode(["Webpage"], { URL: "https://en.wikipedia.org/wiki/SpongeBob_SquarePants" })
    ),
   ]
)

const result: EnhancedNode[] = await mango.mergeEnhancedNodes([person, wiki]);
console.log(result[0].isWritten()); // true
console.log(result[1].isWritten()); // true
```

Returns **[Promise][41]<(Result | [Array][39]\<EnhancedNode>)>** 

### buildAndMergeEnhancedNode

Builds and merges EnhancedNode (a subgraph) to Neo4j.
Ensures that specified pattern exists in Neo4j.
Allows a user-friendly declaration of a graph pattern that needs to be merged into Neo4j.

#### Parameters

*   `$0` **SimplifiedEnhancedNode** 

    *   `$0.labels`  
    *   `$0.properties`  
    *   `$0.relationships`  
*   `config` **[Object][37]**  (optional, default `{}`)
*   `graphPattern` **SimplifiedEnhancedNode** a graph pattern (aka EnhancedNode) to be built and merged into Neo4j.

#### Examples

```javascript
import { isEnhancedNode, log } from 'mango';

// Create the following pattern in Neo4j:
// (:Person { NAME: "SpongeBob" })-[:HAS_FRIEND]->(:Person { NAME: "Patrick" })

let person: EnhancedNode = await mango.buildAndMergeEnhancedNode({
 labels: ["Person"],
 properties: { NAME: "Sponge Bob" },
 relationships: [
   {
     labels: ["HAS_FRIEND"],
     partnerNode: { labels: ["Person"], properties: { NAME: "Patrick" } },
   },
 ],
});

log(isEnhancedNode(person)); // true
log(person.isWritten());     // true <- pattern is written to Neo4j
```

Returns **[Promise][41]<(Result | EnhancedNode)>** 

### buildAndMergeEnhancedNodes

Builds and merges EnhancedNode (a subgraph) to Neo4j.
Ensures that specified pattern exists in Neo4j.
Allows a user-friendly declaration of a graph pattern that needs to be merged into Neo4j.

#### Parameters

*   `graphPatterns` **[Array][39]\<SimplifiedEnhancedNode>** 
*   `config` **[Object][37]**  (optional, default `{}`)
*   `graphPattern` **SimplifiedEnhancedNode** a graph pattern (aka EnhancedNode) to be built and merged into Neo4j.

#### Examples

```javascript
import { isEnhancedNode, log } from 'mango';

// Create the following pattern in Neo4j:
// (:Person { NAME: "SpongeBob" })-[:HAS_FRIEND]->(:Person { NAME: "Patrick" })

let person: EnhancedNode = await mango.buildAndMergeEnhancedNode({
 labels: ["Person"],
 properties: { NAME: "Sponge Bob" },
 relationships: [
   {
     labels: ["HAS_FRIEND"],
     partnerNode: { labels: ["Person"], properties: { NAME: "Patrick" } },
   },
 ],
});

log(isEnhancedNode(person)); // true
log(person.isWritten());     // true <- pattern is written to Neo4j
```

Returns **[Promise][41]<(Result | EnhancedNode)>** 

### deleteNode

Removes Node/EnhancedNode and all its Relationships from Neo4j.

#### Parameters

*   `node` **([Node][42] | EnhancedNode)** Node to delete.
*   `config` **[Object][37]** Configuration object. (optional, default `{}`)

    *   `config.archiveNodes` **[boolean][40]** {true} does not delete anything. Instead it sets { \_isCurrent: false, \_dateArchived: TimeArray } on Node & all its Relationships.{false} permanently deletes Nodes and all its Relations. (optional, default `false`)

#### Examples

```javascript
const mango = new Mango({ engineConfig });
const bob = await mango.findNode(["Person"], { fullName: 'SpongeBob SquarePants' });
const rv =
 mango
 .deleteNode(bob)
 .then(node => {
   // node == EnhancedNode that specifies all Relationships that were affected
   console.log(node.getProperty('_hasBeenDeleted')); // true
   console.log(node.getProperty('_whenWasDeleted')); // [year, month, day, weekday, timestamp]
   console.log(node.getProperty('_isArchived')); // false
 })
```

Returns **[Promise][41]\<Result>** Returns Result where Result.data contains affected Node and its Relationships.

### decomposeProps

Helper method to classify a POJO's properties into REQUIRED/optional/\_private types.
Used by Mango to create unique Nodes based on REQUIRED properties.

#### Parameters

*   `props` **[Object][37]** 

#### Examples

```javascript
const rv = new Mango().decomposeProps({
 SOMETHINGIMPORTANT: 'foo',
 somethingOptional: 'bar',
 _andSomePrivateProp: 'kek'
 });
console.log(rv);
// {
//  requiredProps: { SOMETHINGIMPORTANT: 'foo' },
//  optionalProps: { somethingOptional: 'bar' },
//  privateProps: { _andSomePrivateProp: 'kek' },
// }
```

Returns **{requiredProps: [Object][37], optionalProps: [Object][37], privateProps: [Object][37]}** 

### search

A shortcut to create a search condition.

#### Parameters

*   `condition` **[string][38]** Condition for value search ( > < >= <= == etc. ).
*   `value` **any** Searched value.

Returns **[ConditionContainer][43]** 

## ConditionContainer

Represents a searched value and its search condition.

### Parameters

*   `condition` **[string][38]** Condition for value search ( > < >= <= == etc. ).
*   `value` **any** Searched value.

### getType

Helper method to check value's type.

Returns **any** value type

### toObject

Helper method to unwrap value.

Returns **[Object][37]** { condition: value }.

[1]: #mango

[2]: #parameters

[3]: #examples

[4]: #findnode

[5]: #parameters-1

[6]: #examples-1

[7]: #buildandmergenode

[8]: #parameters-2

[9]: #examples-2

[10]: #buildandmergerelationship

[11]: #parameters-3

[12]: #examples-3

[13]: #mergeenhancednode

[14]: #parameters-4

[15]: #examples-4

[16]: #mergeenhancednodes

[17]: #parameters-5

[18]: #examples-5

[19]: #buildandmergeenhancednode

[20]: #parameters-6

[21]: #examples-6

[22]: #buildandmergeenhancednodes

[23]: #parameters-7

[24]: #examples-7

[25]: #deletenode

[26]: #parameters-8

[27]: #examples-8

[28]: #decomposeprops

[29]: #parameters-9

[30]: #examples-9

[31]: #search

[32]: #parameters-10

[33]: #conditioncontainer

[34]: #parameters-11

[35]: #gettype

[36]: #toobject

[37]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object

[38]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String

[39]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array

[40]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean

[41]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise

[42]: https://developer.mozilla.org/docs/Web/API/Node/nextSibling

[43]: #conditioncontainer
